<!doctype html>
<html lang=en>
<head>
<meta charset=utf-8>
<title>web/api/users.js - Ciro Santilli</title>
<meta property="og:title" content="web/api/users.js - Ciro Santilli">
<meta property="og:type" content="website">
<meta property="og:image" content="https://docs.ourbigbook.com/_raw/logo.svg">
<meta property="og:url" content="https://docs.ourbigbook.com/_file/web/api/users.js">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.10.1/css/all.min.css" integrity="sha512-9my9Mb2+0YO+I4PUCSwUYO7sEK21Y0STBAiFEYoWtd2VzLEZZ4QARDrZ30hdM1GlioHJ8o8cWQiy8IAb1hy/Hg==" crossorigin="anonymous" referrerpolicy="no-referrer">
<style>@import "../../../_obb/dist/ourbigbook.css";

</style>
<link rel="stylesheet" type="text/css" href="../../../_raw/main.css">
<link rel="shortcut icon" href="../../../_raw/logo.svg">
</head>
<body>
<header
<div class="brand-group">
<a href="../../../" class="brand"><img src="../../../_raw/logo.svg" alt="OurBigBook logo">OurBigBook Docs</a>
<a href="https://ourbigbook.com" class="brand"><img src="../../../_raw/logo.svg" alt="OurBigBook logo"><span class="mobile-hide">OurBigBook.com</span><span class="mobile-show">Site</span></a>
<a href="https://github.com/ourbigbook/ourbigbook"><i class="fab fa-github fa-fw icon"></i> Source code</a>
</div>
</header>
<main class="ourbigbook">
<div class="h top" id="file/web/api/users.js"><div class="notnav"><span class="file" title="This article is about a file." /><h1><a href="">web/api/users.js</a></h1></div><nav class="h-nav h-nav-toplevel"><div class="nav file"><b> <a href="../../../_dir">(root)</a> / <a href="../../../_dir/web">web</a> / <a href="../../../_dir/web/api">api</a> / <a href="../../../_raw/web/api/users.js">users.js</a></b></div></nav></div><div class="p"><b>web/api/users.js</b></div><div class="code"><div><pre><code>const url = require('url');

const { hashToHex, sendJsonHttp } = require('ourbigbook/web_api')

const axios = require('axios')
const router = require('express').Router()
const passport = require('passport')
const sharp = require('sharp')

const auth = require('../auth')
const lib = require('./lib')
const {
  validateParam,
  ValidationError,
} = lib
const { cant } = require('../front/cant')
const front = require('../front/js')
const { ipBlockedForSignupMessage } = front
const config = require('../front/config')
const routes = require('../front/routes')
const { isIpBlockedForSignup } = require('../back/webpack_safe')

async function authenticate(req, res, next, opts={}) {
  const { forceVerify } = opts
  passport.authenticate('local', { session: false }, async function(err, user, info) {
    if (err) {
      return next(err)
    }
    if (user) {
      if (user.verified || forceVerify) {
        user.token = user.generateJWT()
        verified = true
      } else {
        verified = false
      }
      return res.json({
        user: await user.toJson(user),
        verified,
      })
    } else {
      return res.status(422).json(info)
    }
  })(req, res, next)
}

// Preload user profile on routes with ':username'
router.param('username', function(req, res, next, username) {
  req.app.get('sequelize').models.User.findOne({ where: { username } })
    .then(function(user) {
      if (!user) {
        return res.sendStatus(404)
      }
      req.user = user
      return next()
    })
    .catch(next)
})

// Login to the website.
router.post('/login', async function(req, res, next) {
  try {
    const body = validateParam(req, 'body')
    const user = validateParam(body, 'user')
    const username = validateParam(user, 'username')
    const password = validateParam(user, 'password')
    await authenticate(req, res, next)
  } catch(error) {
    next(error);
  }
})

router.post('/reset-password-request', async function(req, res, next) {
  try {
    const body = validateParam(req, 'body')
    const emailOrUsername = validateParam(body,
      'emailOrUsername',
      { validators: [front.isString, front.isTruthy] }
    )
    await validateCaptcha(config, req, res)
    const sequelize = req.app.get('sequelize')
    const where = {}
    if (front.isEmail(emailOrUsername)) {
      where.email = emailOrUsername
    } else {
      where.username = emailOrUsername
    }
    const User = sequelize.models.User
    const user = await User.findOne({ where })
    if (!user)
      throw new ValidationError([`email or username is not registered: ${emailOrUsername}`])
    if (!user.verified)
      throw new ValidationError([`user is not verified, you must verify your account before you can reset your password`])
    const timeToWaitMs = getTimeToWaitForNextEmailMs(user)
    if (timeToWaitMs &gt; 0) {
      throw new ValidationError([`Email already registered but not verified. You can re-send a confirmation email in: ${lib.msToRoundedTime(timeToWaitMs)}`])
    }
    const verificationCode = User.generateVerificationCode()
    const resetPasswordUrl = `${routes.host(req)}${routes.resetPasswordUpdate()}?email=${encodeURIComponent(user.email)}&amp;code=${verificationCode}`
    user.verificationCode = verificationCode
    user.verificationCodeN += 1
    user.verificationCodeSent = new Date()
    await Promise.all([
      user.saveSideEffects(),
      lib.sendEmail({
        req,
        to: user.email,
        subject: `Change your OurBigBook.com password`,
        html:
          `&lt;p&gt;Hello, ${user.displayName}!&lt;/p&gt;` +
          `&lt;p&gt;Someone (hopefully you) requested a password reset for your account.&lt;/p&gt;` +
          `&lt;p&gt;If that was you, please &lt;a href="${resetPasswordUrl}"&gt;click this link to change your password&lt;/a&gt;.&lt;/p&gt;` +
          `&lt;p&gt;If it wasn't, you can safely ignore this email.&lt;/p&gt;`
        ,
        text: `Hello, ${user.displayName}!

Someone (hopefully you) requested a password reset for your account.

If that was you, please click this link to change your password: ${resetPasswordUrl}

If it wasn't, you can safely ignore this email.
`,
      })
    ])
    res.sendStatus(200)
  } catch(error) {
    next(error);
  }
})

router.post('/reset-password', async function(req, res, next) {
  try {
    const body = validateParam(req, 'body')
    const email = validateParam(body,
      'email',
      { validators: [front.isString, front.isTruthy] }
    )
    const password = validateParam(body,
      'password',
      { validators: [front.isString, front.isTruthy] }
    )
    const code = validateParam(body,
      'code',
      { validators: [front.isString, front.isTruthy] }
    )
    const sequelize = req.app.get('sequelize')
    const User = sequelize.models.User
    const user = await User.findOne({ where: { email } })
    if (!user)
      throw new ValidationError([`email not registered: ${email}`])
    if (code === user.verificationCode) {
      res.sendStatus(200)
      user.verificationCode = null
      user.verificationCodeN = 0
      User.setPassword(user, password)
      await user.saveSideEffects()
    } else {
      throw new ValidationError(['verification code invalid. Please send a new one.'])
    }
  } catch(error) {
    next(error);
  }
})

router.get('/users', auth.optional, async function(req, res, next) {
  try {
    const sequelize = req.app.get('sequelize')
    const { User } = sequelize.models
    const [limit, offset] = lib.getLimitAndOffset(req, res)
    const [loggedInUser, {count: usersCount, rows: users}] = await Promise.all([
      req.payload ? User.findByPk(req.payload.id) : null,
      User.getUsers({
        // https://github.com/ourbigbook/ourbigbook/issues/260
        followedBy: req.query.followedBy,
        following: req.query.following,
        limit,
        offset,
        order: lib.getOrder(req, {
          allowedSorts: User.ALLOWED_SORTS,
          allowedSortsExtra: User.ALLOWED_SORTS_EXTRA,
        }),
        sequelize,
        username: req.query.username,
      }),
    ])
    return res.json({
      users: await Promise.all(users.map((user) =&gt; {
        return user.toJson(loggedInUser)
      })),
      usersCount,
    })
  } catch(error) {
    next(error);
  }
})

async function validateCaptcha(config, req, res) {
  if (config.useCaptcha) {
    const {data, status} = await sendJsonHttp(
      'POST',
      '/recaptcha/api/siteverify',
      {
        contentType: 'application/x-www-form-urlencoded',
        https: true,
        hostname: 'www.google.com',
        validateStatus: () =&gt; true,
        body: new url.URLSearchParams({
          secret: process.env.RECAPTCHA_SECRET_KEY,
          response: req.body.recaptchaToken,
        }).toString(),
      }
    )
    if (status !== 200) {
      return res.sendStatus(503)
    }
    if (!data.success) {
      console.error(`recaptcha error: ${data}`);
      throw new ValidationError(['reCAPTCHA failed'])
    }
  }
}

function getTimeToWaitForNextEmailMs(user) {
  if (user.verificationCodeN === 0)
    return -1
  return (
    user.verificationCodeSent.getTime() +
    lib.MILLIS_PER_MINUTE * user.sequelize.models.User.verificationCodeNToTimeDeltaMinutes(user.verificationCodeN)
  ) - (new Date()).getTime()
}

// Create a new user.
router.post('/users', async function(req, res, next) {
  try {
    const body = validateParam(req, 'body')
    const userPost = validateParam(body, 'user')
    const username = validateParam(userPost, 'username')
    const email = validateParam(userPost, 'email')
    const password = validateParam(userPost, 'password')
    const displayName = validateParam(userPost, 'displayName', {
      validators: [front.isString, front.isTruthy],
      defaultValue: undefined,
    })
    const sequelize = req.app.get('sequelize')
    const { User } = sequelize.models
    let user
    const ip = front.getClientIp(req)
    await sequelize.transaction(async (transaction) =&gt; {
      const [ipBlockPrefix,] = await Promise.all([
        isIpBlockedForSignup(sequelize, ip),
        validateCaptcha(config, req, res),
      ])
      if (ipBlockPrefix) {
        throw new ValidationError([ipBlockedForSignupMessage(ip, ipBlockPrefix.ip)])
      }

      // Check if VPN and block if yes.
      if (
        ip &amp;&amp;
        config.ipapiIsApiKey
      ) {
        const response = await axios.get(`https://api.ipapi.is?q=${ip}&amp;key=${config.ipapiIsApiKey}`)
        if (response.status === 200) {
          const data = response.data
          if (data.is_vpn) {
            console.log(`ipapi.js VPN detected: ${JSON.stringify(data)}`)
            throw new ValidationError([
              `Your IP ${ip} is from a VPN according to https://ipapi.is ` +
              `which is not allowed due to past abuse. Please try again ` +
              `from another network, or contact a site admin to create the account for you.`
            ])
          }
        } else {
          console.log('ipapi error')
          console.log(response.data)
        }
      }

      // We fetch the existing account by email.
      // https://github.com/ourbigbook/ourbigbook/issues/329
      const existingUser = await User.findOne({ where: { email }, transaction})
      let adminsPromise
      if (existingUser) {
        user = existingUser
        if (user.verified) {
          throw new ValidationError([`email already taken: ${email}`])
        }
        // Re-send the email if enough time passed.
        const timeToWaitMs = getTimeToWaitForNextEmailMs(user)
        if (timeToWaitMs &gt; 0) {
          throw new ValidationError([`Email already registered but not verified. You can re-send a confirmation email in: ${lib.msToRoundedTime(timeToWaitMs)}`])
        }
        user.verificationCode = User.generateVerificationCode()
        user.verificationCodeN += 1
        adminsPromise = null
      } else {
        user = new (User)()
        // username is set only in this else.
        // https://github.com/ourbigbook/ourbigbook/issues/329
        user.username = username
        user.verificationCodeN = 1
        user.email = email
        user.ip = ip
        if (config.isTest) {
          // Authenticate all users automatically.
          user.verified = true
        }
        adminsPromise = User.findAll({ where: { admin: true }, transaction })
      }
      user.displayName = displayName
      User.setPassword(user, password)
      user.verificationCodeSent = new Date()
      const [, admins] = await Promise.all([
        user.saveSideEffects({ transaction }),
        adminsPromise,
      ])
      const verifyUrl = `${routes.host(req)}${routes.userVerify()}?email=${encodeURIComponent(user.email)}&amp;code=${user.verificationCode}`
      const sendEmailsPromises = []
      sendEmailsPromises.push(lib.sendEmail({
        req,
        to: user.email,
        subject: `Verify your new OurBigBook.com account`,
        html:
          `&lt;p&gt;Welcome to OurBigBook.com, ${user.displayName}!&lt;/p&gt;` +
          `&lt;p&gt;Please &lt;a href="${verifyUrl}"&gt;click this link to verify your account&lt;/a&gt;.&lt;/p&gt;`
        ,
        text: `Welcome to OurBigBook.com, ${user.displayName}!

Please click this link to verify your account: ${verifyUrl}
`,
      }))
      const profileUrl = `${routes.host(req)}${routes.user(user.username)}`
      if (admins) {
        for (const admin of admins) {
          sendEmailsPromises.push(lib.sendEmail({
            req,
            to: admin.email,
            subject: `A new user signed up: ${user.displayName} (@${user.username}, ${user.email}, ${user.ip})!`,
            html: `&lt;p&gt;&lt;a href="${profileUrl}"&gt;${profileUrl}&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Another step towards world domination is taken!&lt;/p&gt;`,
            text: `${profileUrl}

Another step towards world domination is taken!
`,
          }))
        }
      }
      await Promise.all(sendEmailsPromises)
    })
    if (config.isTest) {
      // TODO get rid of this horror.
      return authenticate(req, res, next, { forceVerify: true })
    } else {
      return res.json({ user: await user.toJson(user) })
    }
  } catch(error) {
    next(error);
  }
})

// Modify information about the given logged user.
// Backend for settings page on the web UI.
router.put('/users/:username', auth.required, async function(req, res, next) {
  try {
    const sequelize = req.app.get('sequelize')
    const user = req.user
    const loggedInUser = await sequelize.models.User.findByPk(req.payload.id)
    const msg = cant.editUser(loggedInUser, user)
    if (msg) {
      throw new ValidationError([msg], 403)
    }
    const userArg = req.body.user
    if (userArg) {
      // only update fields that were actually passed...
      if (typeof userArg.username !== 'undefined') {
        //user.username = userArg.username
        if (user.username !== userArg.username) {
          throw new ValidationError(
            [`username cannot be modified currently, would change from ${user.username} to ${userArg.username}`],
          )
        }
      }
      if (typeof userArg.email !== 'undefined') {
        //user.email = userArg.email
        if (user.email !== userArg.email) {
          throw new ValidationError(
            [`email cannot be modified currently, would change from ${user.email} to ${userArg.email}`],
          )
        }
      }
      if (typeof userArg.displayName !== 'undefined') {
        const displayName = validateParam(userArg, 'displayName', {
          validators: [front.isString, front.isTruthy],
          defaultValue: undefined,
        })
        user.displayName = displayName
      }
      const emailNotifications = validateParam(userArg, 'emailNotifications', {
        validators: [front.isBoolean],
        defaultValue: undefined,
      })
      if (emailNotifications !== undefined) {
        user.emailNotifications = userArg.emailNotifications
      }
      const emailNotificationsForArticleAnnouncement = validateParam(userArg, 'emailNotificationsForArticleAnnouncement', {
        validators: [front.isBoolean],
        defaultValue: undefined,
      })
      if (emailNotificationsForArticleAnnouncement !== undefined) {
        user.emailNotificationsForArticleAnnouncement = userArg.emailNotificationsForArticleAnnouncement
      }
      const hideArticleDates = validateParam(userArg, 'hideArticleDates', {
        validators: [front.isBoolean],
        defaultValue: undefined,
      })
      if (hideArticleDates !== undefined) {
        user.hideArticleDates = userArg.hideArticleDates
      }

      // User limits
      {
        const msg = cant.setUserLimits(loggedInUser)
        function set(val, key) {
          if (val !== undefined) {
            if (msg) {
              throw new ValidationError([msg], 403)
            } else {
              user[key] = val
            }
          }
        }
        set(
          validateParam(userArg, 'maxArticles', {
            typecast: front.typecastInteger,
            validators: [front.isPositiveInteger],
            defaultValue: undefined,
          }),
          'maxArticles',
        )
        set(
          validateParam(userArg, 'maxArticleSize', {
            typecast: front.typecastInteger,
            validators: [front.isPositiveInteger],
            defaultValue: undefined,
          }),
          'maxArticleSize',
        )
        set(
          validateParam(userArg, 'maxUploads', {
            typecast: front.typecastInteger,
            validators: [front.isPositiveInteger],
            defaultValue: undefined,
          }),
          'maxUploads',
        )
        set(
          validateParam(userArg, 'maxUploadSize', {
            typecast: front.typecastInteger,
            validators: [front.isPositiveInteger],
            defaultValue: undefined,
          }),
          'maxUploadSize',
        )
        set(
          validateParam(userArg, 'maxIssuesPerMinute', {
            typecast: front.typecastInteger,
            validators: [front.isPositiveInteger],
            defaultValue: undefined,
          }),
          'maxIssuesPerMinute',
        )
        set(
          validateParam(userArg, 'maxIssuesPerHour', {
            typecast: front.typecastInteger,
            validators: [front.isPositiveInteger],
            defaultValue: undefined,
          }),
          'maxIssuesPerHour',
        )
        set(
          validateParam(userArg, 'locked', {
            validators: [front.isBoolean],
            defaultValue: undefined,
          }),
          'locked',
        )
      }

      if (typeof userArg.password !== 'undefined') {
        sequelize.models.User.setPassword(user, userArg.password)
      }
      await user.saveSideEffects()
    }
    user.token = user.generateJWT()
    return res.json({ user: await user.toJson(user) })
  } catch(error) {
    next(error);
  }
})

// Modify image of the currently logged in user.
// Backend for settings page on the web UI.
router.put('/users/:username/profile-picture', auth.required, async function(req, res, next) {
  try {
    let t0
    if (config.log.perf) {
      t0 = performance.now()
    }
    const sequelize = req.app.get('sequelize')
    const user = req.user
    const { Upload, User } = sequelize.models
    const loggedInUser = await User.findByPk(req.payload.id)
    const msg = cant.editUser(loggedInUser, user)
    if (msg) {
      throw new ValidationError([msg], 403)
    }
    const body = validateParam(req, 'body')
    const dataUrl = validateParam(body, 'bytes', { validators: [front.isString] })
    const [contentType, bytesOrig] = lib.parseDataUriBase64(dataUrl)
    if (!config.allowedImageContentTypes.has(contentType)) {
      throw new ValidationError([
        `content type is not allowed: "${contentType}". ` +
        `Allowed content types: ${config.allowedImageContentTypesArr.join(', ')}`
      ], 422)
    }
    const sizeOrig = bytesOrig.length
    if (sizeOrig &gt; config.profilePictureMaxUploadSize) {
      throw new ValidationError([
        `image is too large: ${sizeOrig} bytes, maximum size is ${config.profilePictureMaxUploadSize}`
      ], 422)
    }
    let bytes
    try {
      bytes = await sharp(bytesOrig).resize(250, 250, { fit: 'fill' }).toBuffer()
    } catch(err) {
      throw new ValidationError(`Image conversion failed with: ${err.message}`)
    }
    user.image = `${config.profilePicturePath}/${user.id}`
    t0 = lib.logPerf(t0, 'PUT /users/:username/profile-picture before transaction')
    await sequelize.transaction(async (transaction) =&gt; {
      await Upload.upsertSideEffects(
        {
          bytes,
          contentType,
          path: `${config.profilePicturePathComponent}/${user.id}`,
          size: bytes.length,
          hash: hashToHex(bytes),
        },
        { transaction }
      )
      await user.saveSideEffects({ transaction })
    })
    t0 = lib.logPerf(t0, 'PUT /users/:username/profile-picture after transaction')
    return res.json({})
  } catch(error) {
    next(error);
  }
})

// Follow

async function validateFollow(user, loggedInUser, isFollow) {
  if ((await loggedInUser.hasFollow(user)) === isFollow) {
    throw new ValidationError(
      [`User '${loggedInUser.username}' ${isFollow ? 'already follows' : 'does not follow'} user '${user.username}'`],
      403,
    )
  }
}

// Follow user.
router.post('/users/:username/follow', auth.required, async function(req, res, next) {
  try {
    const sequelize = req.app.get('sequelize')
    const { User } = sequelize.models
    const loggedInUser = await User.findByPk(req.payload.id)
    const user = req.user
    const msg = cant.followUser(loggedInUser, user)
    if (msg) {
      throw new ValidationError([msg], 403)
    }
    await validateFollow(user, loggedInUser, true)
    await loggedInUser.addFollowSideEffects(user)
    const newUser = await User.findOne({ where: { username: loggedInUser.username } })
    return res.json({ user: await user.toJson(newUser) })
  } catch(error) {
    next(error)
  }
})

// Unfollow user.
router.delete('/users/:username/follow', auth.required, async function(req, res, next) {
  try {
    const sequelize = req.app.get('sequelize')
    const { User } = sequelize.models
    const loggedInUser = await User.findByPk(req.payload.id)
    const user = req.user
    const msg = cant.followUser(loggedInUser, user)
    if (msg) {
      throw new ValidationError([msg], 403)
    }
    await validateFollow(user, loggedInUser, false)
    await loggedInUser.removeFollowSideEffects(req.user)
    const newUser = await User.findOne({ where: { username: user.username } })
    return res.json({ user: await req.user.toJson(newUser) })
  } catch(error) {
    next(error)
  }
})

module.exports = router
</code></pre></div></div></main>
<footer>
<div>License: <a href="https://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a> unless noted</div>
<div><a href="../../../_dir">Website source code</a></div>
</footer>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-2XSEK2ND00"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-2XSEK2ND00');
</script>
<script src="https://giscus.app/client.js"
        data-repo="ourbigbook/ourbigbook"
        data-repo-id="MDEwOlJlcG9zaXRvcnkyMTEyOTA2NzA="
        data-category="giscus"
        data-category-id="DIC_kwDODJgKLs4CZ61S"
        data-mapping="pathname"
        data-strict="0"
        data-reactions-enabled="1"
        data-emit-metadata="0"
        data-input-position="bottom"
        data-theme="dark_high_contrast"
        data-lang="en"
        crossorigin="anonymous"
        async>
</script>
<script>
window.ourbigbook_split_headers = false;
window.ourbigbook_html_x_extension = false;
window.ourbigbook_redirect_prefix = "";
</script>
<script src="../../../_obb/dist/ourbigbook_runtime.js"></script><script>ourbigbook_runtime.ourbigbook_runtime()</script></body>
</html>
