<!doctype html>
<html lang=en>
<head>
<meta charset=utf-8>
<title>web/front/EditorPage.tsx - Ciro Santilli</title>
<meta property="og:title" content="web/front/EditorPage.tsx - Ciro Santilli">
<meta property="og:type" content="website">
<meta property="og:image" content="https://docs.ourbigbook.com/_raw/logo.svg">
<meta property="og:url" content="https://docs.ourbigbook.com/_file/web/front/EditorPage.tsx">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.10.1/css/all.min.css" integrity="sha512-9my9Mb2+0YO+I4PUCSwUYO7sEK21Y0STBAiFEYoWtd2VzLEZZ4QARDrZ30hdM1GlioHJ8o8cWQiy8IAb1hy/Hg==" crossorigin="anonymous" referrerpolicy="no-referrer">
<style>@import "../../../_obb/dist/ourbigbook.css";

</style>
<link rel="stylesheet" type="text/css" href="../../../_raw/main.css">
<link rel="shortcut icon" href="../../../_raw/logo.svg">
</head>
<body>
<header
<div class="brand-group">
<a href="../../../" class="brand"><img src="../../../_raw/logo.svg" alt="OurBigBook logo">OurBigBook Docs</a>
<a href="https://ourbigbook.com" class="brand"><img src="../../../_raw/logo.svg" alt="OurBigBook logo"><span class="mobile-hide">OurBigBook.com</span><span class="mobile-show">Site</span></a>
<a href="https://github.com/ourbigbook/ourbigbook"><i class="fab fa-github fa-fw icon"></i> Source code</a>
</div>
</header>
<main class="ourbigbook">
<div class="h top" id="file/web/front/EditorPage.tsx"><div class="notnav"><span class="file" title="This article is about a file." /><h1><a href="">web/front/EditorPage.tsx</a></h1></div><nav class="h-nav h-nav-toplevel"><div class="nav file"><b> <a href="../../../_dir">(root)</a> / <a href="../../../_dir/web">web</a> / <a href="../../../_dir/web/front">front</a> / <a href="../../../_raw/web/front/EditorPage.tsx">EditorPage.tsx</a></b></div></nav></div><div class="p"><b>web/front/EditorPage.tsx</b></div><div class="code"><div><pre><code>import { loader } from '@monaco-editor/react'
import React, { useEffect, useRef, useState, } from 'react'
import Router, { useRouter } from 'next/router'
import Link from 'next/link'

import lodash from 'lodash'
import pluralize from 'pluralize'

import ourbigbook, { TXT_HOME_MARKER } from 'ourbigbook'
import ourbigbook_tex from 'ourbigbook/default.tex'
import web_api from 'ourbigbook/web_api'
import { preload_katex } from 'ourbigbook/nodejs_front'
import { ourbigbook_runtime } from 'ourbigbook/dist/ourbigbook_runtime.js'
import { OurbigbookEditor } from 'ourbigbook/editor.js'
import { convertOptions, docsUrl, forbidMultiheaderMessage, sureLeaveMessage, isProduction, read_include_web } from 'front/config'

import {
  ArticleBy,
  capitalize,
  disableButton,
  enableButton,
  CancelIcon,
  EditArticleIcon,
  HelpIcon,
  MoreIcon,
  OkIcon,
  slugFromArray,
  useWindowEventListener,
  TopicIcon,
  DiscussionIcon,
  NewArticleIcon,
} from 'front'
import ErrorList from 'front/ErrorList'
import { webApi } from 'front/api'
import routes from 'front/routes'
import { MyHead, useCtrlEnterSubmit } from 'front'
import { hasReachedMaxItemCount, idToTopic } from 'front/js'
import Label from 'front/Label'

import { ArticleType } from 'front/types/ArticleType'
import { CommonPropsType } from 'front/types/CommonPropsType'
import { IssueType } from 'front/types/IssueType'
import { displayAndUsernameText } from 'front/user'
import CustomLink from './CustomLink'

export interface EditorPageProps extends CommonPropsType {
  article: ArticleType &amp; IssueType;
  articleCountByLoggedInUser: number;
  issueArticle?: ArticleType;
  parentTitle?: string,
  previousSiblingTitle?: string,
  titleSource?: string;
  titleSourceLine?: number;
}

/** DbProvider that fetchs data via the OurBigBook Web REST API. */
class RestDbProvider extends web_api.DbProviderBase {
  fetched_ids: Set&lt;string&gt;;
  fetched_files: Set&lt;string&gt;;

  constructor() {
    super()
    this.fetched_ids = new Set()
    this.fetched_files = new Set()
  }

  async get_noscopes_base_fetch(ids, ignore_paths_set, context) {
    const unfetched_ids = []
    for (const id of ids) {
      if (
        // Small optimization, don't fetch IDs that don't start with @, that is the case for every web ID.
        // And if there are two @, it means user is doing &lt;@other-user/mytopic&gt;, so we also don't need
        // to try and fetch &lt;@myself/@other-user/mytopic&gt;
        (id.match(new RegExp(ourbigbook.AT_MENTION_CHAR, 'g')) || []).length === 1 &amp;&amp;
        !this.fetched_ids.has(id)
      ) {
        this.fetched_ids.add(id)
        unfetched_ids.push(id)
      }
    }
    if (unfetched_ids.length) {
      const { data: { rows }, status } = await webApi.editorGetNoscopesBaseFetch(unfetched_ids, Array.from(ignore_paths_set))
      // @ts-ignore: Property 'rows_to_asts' does not exist on type 'RestDbProvider'.
      return this.rows_to_asts(rows, context)
    } else {
      return []
    }
  }

  async get_refs_to_fetch(types, to_ids, { reversed, ignore_paths_set, context }) {
    return []
  }

  async fetch_header_tree_ids(starting_ids_to_asts) {
    return []
  }

  async fetch_ancestors(toplevel_id) {
    return []
  }

  build_header_tree(fetch_header_tree_ids_rows, { context }) {
    return []
  }

  fetch_ancestors_build_tree(rows, context) {
    return []
  }

  get_refs_to(type, to_id, reversed=false) {
    return []
  }

  async fetch_files(paths, context) {
    const unfetched_files = []
    for (const path of paths) {
      if (!this.fetched_files.has(path)) {
        this.fetched_files.add(path)
        unfetched_files.push(path)
      }
    }
    if (unfetched_files.length) {
      const { data: { files }, status } = await webApi.editorFetchFiles(unfetched_files)
      for (const file of files) {
        // This was likely not fixed for the editor case: https://github.com/ourbigbook/ourbigbook/issues/240
        // But I'll just pretend it's fine for now until this gets digged up a few years later.
        // @ts-ignore: Property 'add_file_row_to_cache' does not exist on type 'RestDbProvider'.
        this.add_file_row_to_cache(file, context)
      }
    }
  }
}

function titleToId(username, title) {
  let ret = `${ourbigbook.AT_MENTION_CHAR}${username}`
  const topicId = ourbigbook.titleToId(title, { keepScopeSep: true })
  if (topicId !== ourbigbook.INDEX_BASENAME_NOEXT) {
    ret += `/${topicId}`
  }
  return ret
}

function titleToPath(username, title) {
  return `${titleToId(username, title)}.${ourbigbook.OURBIGBOOK_EXT}`
}

const idExistsCache = {}
async function cachedIdExists(idid) {
  if (idid in idExistsCache) {
    return idExistsCache[idid]
  } else {
    const ret = await webApi.editorIdExists(idid)
    idExistsCache[idid] = ret
    return ret
  }
}

const parentTitleDisplay = 'Parent article'
const previousSiblingTitleDisplay = 'Previous sibling'
const metadataTabId = `${ourbigbook.Macro.RESERVED_ID_PREFIX}metadata`

export default function EditorPageHoc({
  isIssue=false,
  isNew=false,
}={}) {
  const editor = function EditorPage({
    article: initialArticle,
    articleCountByLoggedInUser,
    issueArticle,
    loggedInUser,
    parentTitle: initialParentTitle,
    previousSiblingTitle: initialPreviousSiblingTitle,
    titleSource,
  }: EditorPageProps) {
    const router = useRouter()
    const {
      query: { slug },
    } = router
    let bodySource
    let slugString
    if (Array.isArray(slug)) {
      slugString = slug.join('/')
    } else {
      slugString = slug
    }
    let initialFileState
    let initialFile
    let isIndex
    if (!isNew &amp;&amp; !isIssue) {
      isIndex = initialArticle.topicId === ''
    } else {
      isIndex = false
    }
    if (initialArticle &amp;&amp; !(isNew &amp;&amp; isIssue)) {
      initialFile = isIssue ? initialArticle : initialArticle.file
      bodySource = initialFile.bodySource
      if (slugString &amp;&amp; isNew &amp;&amp; !isIssue) {
        bodySource += `${ourbigbook.PARAGRAPH_SEP}Adapted from: \\x[${ourbigbook.AT_MENTION_CHAR}${slugString}].`
      }
      let curTitleSource = initialFile.titleSource
      if (curTitleSource === undefined) {
        curTitleSource = titleSource
      }
      initialFileState = {
        titleSource: curTitleSource
      }
    } else {
      bodySource = ""
      initialFileState = {
        titleSource: titleSource || '',
      }
    }
    const itemType = isIssue ? 'discussion' : 'article'

    // State
    const [isLoading, setLoading] = useState(false)
    const [topicId, setTopicId] = useState('')
    const [editorLoaded, setEditorLoading] = useState(false)
    // TODO titleErrors can be undefined immediately after this call,
    // if the server gives 500 after update. It is some kind of race condition
    // and then it blows up at a later titleErrors.length. It is some kind of race
    // condition that needs debugging at some point.
    const [titleErrors, setTitleErrors] = useState([])
    const [convertTitleErrors, setConvertTitleErrors] = useState([])
    const [parentErrors, setParentErrors] = useState([])
    const [hasConvertError, setHasConvertError] = useState(false)
    const [file, setFile] = useState(initialFileState)
    const [parentTitle, setParentTitle] = useState(initialParentTitle || 'Index')
    const [previousSiblingTitle, setPreviousSiblingTitle] = useState(initialPreviousSiblingTitle || '')
    const [tab, setTab] = useState('editor')
    const [list, setList] = useState(initialArticle === null ? true : initialArticle.list)
    const ourbigbookEditorElem = useRef(null)
    const ourbigbookHeaderElem = useRef(null)
    const ourbigbookParentIdContainerElem = useRef(null)
    const saveButtonElem = useRef(null)
    const parentInputElem = useRef(null);

    const maxReached = hasReachedMaxItemCount(loggedInUser, articleCountByLoggedInUser, pluralize(itemType))
    let ownerUsername: string
    if (isNew) {
      ownerUsername = loggedInUser?.username
    } else {
      ownerUsername = initialArticle.author.username
    }
    async function checkTitle(titleSource) {
      let titleErrors = []
      if (!titleSource &amp;&amp; !isIndex) {
        titleErrors.push('Title cannot be empty')
      }
      setTitleErrors(titleErrors)
    }
    useEffect(() =&gt; {
      // Initial check here, then check only on title update.
      checkTitle(file.titleSource)
    }, [file.titleSource])

    // Ask for confirmation before leaving page with:
    // - tab close
    // - history back button
    // if any changes were made to editor. In this page we:
    // - can only exit with router on Cancel, and that is handled there
    // - every other link opens a new page.
    // This is why we don't use useConfirmExitPage, as it handles the
    // Router.push case which is not needed in this case.
    function beforeUnloadConfirm() {
      if (ourbigbookEditorElem.current.ourbigbookEditor.modified) {
        // Message not really shown, there's no way:
        // https://stackoverflow.com/questions/38879742/is-it-possible-to-display-a-custom-message-in-the-beforeunload-popup
        return sureLeaveMessage
      }
    }
    useWindowEventListener('beforeunload', beforeUnloadConfirm)

    const hasError = hasConvertError ||
      titleErrors.length ||
      convertTitleErrors.length ||
      parentErrors.length
    if (
      // Can fail on maximum number of articles reached.
      saveButtonElem.current
    ) {
      if (hasError) {
        disableButton(saveButtonElem.current)
      } else {
        enableButton(saveButtonElem.current)
      }
    }
    const handleSubmit = async (e) =&gt; {
      if (e) {
        e.preventDefault()
      }
      if (hasError) {
        // Although the button should be disabled from clicks,
        // this could still be reached via the Ctrl shortcut.
        return
      }
      setLoading(true)
      let data, status
      file.bodySource = ourbigbookEditorElem.current.ourbigbookEditor.getValue()
      if (isIssue) {
        if (isNew) {
          ;({ data, status } = await webApi.issueCreate(slugString, file))
        } else {
          ;({ data, status } = await webApi.issueEdit(slugString, router.query.number, file))
        }
      } else {
        const opts: {
          list: boolean;
          owner: string;
          path?: string;
          parentId?: string;
          previousSiblingId?: string;
        } = {
          list,
          owner: ownerUsername,
        }
        if (!isIndex) {
          opts.parentId = titleToId(ownerUsername, parentTitle)
          if (previousSiblingTitle) {
            opts.previousSiblingId = titleToId(ownerUsername, previousSiblingTitle)
          }
        }
        if (isNew) {
          ;({ data, status } = await webApi.articleCreate(file, opts))
        } else {
          const path = slugFromArray(
            ourbigbook.pathSplitext(initialFile.path)[0].split(ourbigbook.Macro.HEADER_SCOPE_SEPARATOR),
            { username: false }
          )
          if (path) {
            opts.path = path
          }
          ;({ data, status } = await webApi.articleCreateOrUpdate(file, opts))
        }
      }
      setLoading(false)
      if (status === 200) {
        // This is a hack for the useEffect cleanup callback issue.
        ourbigbookEditorElem.current.ourbigbookEditor.dispose()

        let redirTarget
        if (isIssue) {
          redirTarget = routes.issue(slugString, data.issue.number)
        } else {
          if (isNew) {
            redirTarget = routes.article(data.articles[0].slug)
          } else {
            redirTarget = routes.article(slugString)
          }
        }
        Router.push(redirTarget, null, { scroll: true })
      } else {
        let errors = data.errors
        if (!errors) {
          errors = [`An error ocurred: ${status}`]
        }
        setTitleErrors(errors)
      }
    }
    // https://github.com/ourbigbook/ourbigbook/issues/222
    if (ourbigbookEditorElem.current &amp;&amp; ourbigbookEditorElem.current.ourbigbookEditor) {
      ourbigbookEditorElem.current.ourbigbookEditor.handleSubmit = handleSubmit
    }
    useEffect(() =&gt; {
      if (
        ourbigbookEditorElem.current &amp;&amp;
        loggedInUser &amp;&amp;
        !maxReached
      ) {
        let editor
        loader.init().then(monaco =&gt; {
          const finalConvertOptions = lodash.merge({
            db_provider: new RestDbProvider(),
            forbid_multiheader: isIssue ? undefined : forbidMultiheaderMessage,
            input_path: initialFile?.path || titleToPath(ownerUsername, 'asdf'),
            katex_macros: preload_katex(ourbigbook_tex),
            ourbigbook_json: {
              openLinksOnNewTabs: true,
            },
            read_include: read_include_web(cachedIdExists),
            ref_prefix: `${ourbigbook.AT_MENTION_CHAR}${ownerUsername}`,
          }, convertOptions)
          finalConvertOptions.automaticTopicLinksMaxWords = 0
          finalConvertOptions.x_external_prefix = '../'.repeat(window.location.pathname.match(/\//g).length - 1)
          editor = new OurbigbookEditor(
            ourbigbookEditorElem.current,
            bodySource,
            monaco,
            ourbigbook,
            ourbigbook_runtime,
            {
              convertOptions: finalConvertOptions,
              handleSubmit,
              initialLine: initialArticle ? initialArticle.titleSourceLine : undefined,
              modifyEditorInput: ourbigbook.modifyEditorInput,
              titleSource: initialFileState.titleSource,
              postBuildCallback: async (extra_returns, ourbigbookEditor) =&gt; {
                setHasConvertError(extra_returns.errors.length &gt; 0)

                let titleErrors = []
                if (!isIssue) {
                  const newId = extra_returns.context.header_tree.children[0].ast.id
                  let newTopicId = idToTopic(newId)
                  setTopicId(newTopicId)
                  let showToUserNew
                  if (newTopicId === ourbigbook.INDEX_BASENAME_NOEXT) {
                    // Maybe there is a more factored out way of dealing with this edge case.
                    newTopicId = ''
                    showToUserNew = ourbigbook.INDEX_BASENAME_NOEXT
                  } else {
                    showToUserNew = newTopicId
                  }
                  if (isNew) {
                    if (newTopicId) {
                      const id = `${ourbigbook.AT_MENTION_CHAR}${ownerUsername}/${newTopicId}`
                      if (await cachedIdExists(id)) {
                        titleErrors.push(`ID already taken: "${id}" `)
                      }
                    } else {
                      if (ourbigbookEditor.titleSource) {
                        titleErrors.push(`ID cannot be empty`)
                      }
                    }
                  } else if (!isIssue &amp;&amp; initialArticle.topicId !== newTopicId) {
                    let showToUserOld
                    if (initialArticle?.topicId === '') {
                      showToUserOld = ourbigbook.INDEX_BASENAME_NOEXT
                    } else {
                      showToUserOld = initialArticle?.topicId
                    }
                    titleErrors.push(`ID changed from "${showToUserOld}" to "${showToUserNew}", this is not currently allowed`)
                  }
                }
                setConvertTitleErrors(titleErrors)

                const first_header = extra_returns.context.header_tree.children[0]
                if (isNew &amp;&amp; first_header) {
                  const id = first_header.ast.id
                  // TODO
                  // Not working because finalConvertOptions.input_path setting in handleTitle
                  // not taking effect. This would be the better way to check for it.
                  //if (initialFileState.titleSource &amp;&amp; cachedIdExists(id)) {
                  //  setTitleErrors([`Article ID already taken: "${id}"`])
                  //}
                }
              },
              production: isProduction,
              scrollPreviewToSourceLineCallback: (
                opts : {
                  line_number?: number;
                  line_number_orig?: number;
                  ourbigbook_editor?: any;
                } = {}
              ) =&gt; {
                const { ourbigbook_editor, line_number, line_number_orig } = opts
                const editor = ourbigbook_editor.editor
                const visibleRange = editor.getVisibleRanges()[0]
                const firstVisibleLine = visibleRange.startLineNumber
                if (firstVisibleLine === 1) {
                  ourbigbookHeaderElem.current.classList.remove('hide')
                  if (
                    // Fails for index page.
                    ourbigbookParentIdContainerElem.current !== null
                  ) {
                    ourbigbookParentIdContainerElem.current.classList.remove('hide')
                  }
                } else {
                  if (
                    // TODO this is to prevent infinite loop/glitching:
                    // - user left line 1, hide header
                    // - editor becomes larger, but text is not much larger than the small viewport, so line 1 now visible again, show header
                    // - loop
                    // What we would like is to find the correct number of lines without hardcoding this line count
                    // That hardcoded number is a number of lines that is taller than what gets hidden,
                    // which was about 5 lines high when this was hardcoded.
                    // Maybe something smarter can be done with editor.onDidLayoutChange.
                    editor.getModel().getLineCount() - (visibleRange.endLineNumber - visibleRange.startLineNumber) &gt; 14
                  ) {
                    ourbigbookHeaderElem.current.classList.add('hide')
                    ourbigbookParentIdContainerElem.current.classList.add('hide')
                  }
                }
              },
            },
          )
          if (isIndex) {
            editor.editor.focus()
          }
          ourbigbookEditorElem.current.ourbigbookEditor = editor
          // To ensure an initial conversion in case user has modified title before the editor had loaded.
          // Otherwise title would only update if user edited title again.
          setEditorLoading(true)
        })
        return () =&gt; {
          // TODO cleanup here not working.
          // Blows exception when changing page title because scroll callback calls for the new page.
          // This also leads the redirected article page to be at a random scroll and not on top.
          // Maybe try to extract a solution from:
          // https://github.com/suren-atoyan/monaco-react/blob/9acaf635caf6d738173e53434984252baa8b06d9/src/Editor/Editor.js
          // What happens: order is ArticlePage -&gt; onDidScrollChange -&gt; dispose
          // but we need dispose to be the first thing.
          //ourbigbookEditorRef.current.ourbigbookEditor.dispose()
          if (editor) {
            editor.dispose()
          }
        }
      }
    }, [
      bodySource,
      initialFileState.titleSource,
      // TODO this is a dependency, but if we add it
      // we get back the error where the editor goes blank on error.
      // This is related to https://github.com/ourbigbook/ourbigbook/issues/222
      //handleSubmit,
      initialArticle,
      initialArticle?.titleSourceLine,
      initialFile?.path,
      loggedInUser,
      maxReached,
      ownerUsername
    ])
    async function checkParent(title, otherTitle, display) {
      const parentErrors = []
      if (title) {
        const id = titleToId(ownerUsername, title)
        if (!(await cachedIdExists(id))) {
          parentErrors.push(`${display} ID "${id}" does not exist`)
        }
      } else if (!otherTitle) {
        parentErrors.push(`${parentTitleDisplay} and ${previousSiblingTitleDisplay} can't both be empty`)
      }
      setParentErrors(parentErrors)
    }
    const handleParentTitle = async (e) =&gt; {
      const title = e.target.value
      setParentTitle(title)
      await checkParent(title, previousSiblingTitle, parentTitleDisplay)
    }
    const handlePreviousSiblingTitle = async (e) =&gt; {
      const title = e.target.value
      setPreviousSiblingTitle(title)
      await checkParent(title, parentTitle, previousSiblingTitleDisplay)
    }
    const handleTitle = async (e) =&gt; {
      const titleSource = e.target.value
      setFile(file =&gt; { return {
        ...file,
        titleSource,
      }})
      checkTitle(titleSource)
      // TODO this would be slightly better, but not taking effect, I simply can't understand why,
      // there appear to be no copies of convertOptions under editor...
      //if (titleSource) {
      //  finalConvertOptions.input_path = titleToPath(loggedInUser, titleSource)
      //}
    }
    useEffect(() =&gt; {
      if (
        // Can fail on maximum number of articles reached.
        ourbigbookEditorElem.current &amp;&amp;
        // Can fail is user starts editing title quickly after page load before editor had time to load.
        ourbigbookEditorElem.current.ourbigbookEditor
      ) {
        ourbigbookEditorElem.current.ourbigbookEditor.setTitleSource(file.titleSource)
      }
    }, [file, editorLoaded])
    useCtrlEnterSubmit(handleSubmit)
    const handleCancel = async (e) =&gt; {
      if (!ourbigbookEditorElem.current.ourbigbookEditor.modified || confirm('Are you sure you want to abandon your changes?')) {
        if (isNew) {
          Router.push(`/`)
        } else {
          // This is a hack for the useEffect cleanup callback issue.
          ourbigbookEditorElem.current.ourbigbookEditor.dispose()
          Router.push(routes.article(initialArticle.slug))
        }
      }
    }
    const title = isNew
      ? `New ${itemType}`
      : `Editing ${isIssue
          ? `discussion #${initialFile.number} "${initialFile.titleSource}" on ${issueArticle.titleSource} by ${issueArticle.author.displayName}`
          : isIndex
            ? TXT_HOME_MARKER
            : `"${initialFile.titleSource}"` +
              `${initialArticle.author.id === loggedInUser.id
                ? ''
                : `by ${displayAndUsernameText(initialArticle.author)}`
              }`
        }`

    // Tabs
    function goToTab() {
      const hash = window.location.hash
      let tab
      if (hash === '#_metadata') {
        tab = 'metadata'
      } else {
        tab = 'editor'
      }
      setTab(tab)
    }
    useEffect(() =&gt; {
      const onHashChange = () =&gt; {
        goToTab()
      }
      goToTab()
      window.addEventListener('hashchange', onHashChange)
      return () =&gt; window.removeEventListener('hashchange', onHashChange)
    })

    const titleInputElem = useRef(null)
    useEffect(() =&gt; {
      if (titleInputElem.current) {
        titleInputElem.current.focus()
      }
    }, [])

    return &lt;&gt;
      &lt;MyHead title={title} /&gt;
      &lt;div className="editor-page content-not-ourbigbook"&gt;
        { maxReached
          ? &lt;p&gt;{maxReached}&lt;/p&gt;
          : &lt;&gt;
              &lt;div className="header" ref={ourbigbookHeaderElem}&gt;
                &lt;h1&gt;
                  {isNew
                    ? &lt;&gt;
                        &lt;NewArticleIcon /&gt; New {itemType}
                        {(!isIssue &amp;&amp; topicId) &amp;&amp; &lt;&gt;
                          {' '}on &lt;span className="meta"&gt;
                            &lt;CustomLink href={routes.topic(topicId)} newTab={true}&gt;&lt;TopicIcon /&gt; {topicId}&lt;/CustomLink&gt;
                          &lt;/span&gt;
                        &lt;/&gt;}
                      &lt;/&gt;
                    : &lt;&gt;
                        &lt;EditArticleIcon /&gt; Editing
                        {' '}
                        {isIssue
                          ? &lt;CustomLink
                              href={
                                isIssue
                                  ? routes.issue(issueArticle.slug, initialArticle.number)
                                  : routes.article(initialArticle.slug)
                              }
                              newTab={true}
                            &gt;
                              &lt;DiscussionIcon /&gt; Discussion #{initialArticle.number} "{initialFile?.titleSource}"
                            &lt;/CustomLink&gt;
                          : &lt;&gt;
                              &lt;ArticleBy
                                article={initialArticle}
                                newTab={true}
                                showAuthor={initialArticle.author.id !== loggedInUser.id}
                                showArticleIcon={!isIndex}
                                showTopicId={
                                  !isIndex &amp;&amp;
                                  ourbigbook.titleToId(initialFile.titleSource) !== initialArticle.topicId
                                }
                              /&gt;
                            &lt;/&gt;
                        }
                      &lt;/&gt;
                  }
                  {isIssue &amp;&amp; &lt;&gt; on &lt;ArticleBy article={issueArticle} newTab={true}/&gt;&lt;/&gt;}
                &lt;/h1&gt;
                &lt;Label
                  className={isIndex ? 'hide' : ''}
                  flex={true}
                  label="Title"
                &gt;
                  &lt;input
                    className="title"
                    onChange={handleTitle}
                    onKeyDown={(e) =&gt; {
                      if (e.key === 'Tab') {
                        e.preventDefault();
                        if (tab === 'editor') {
                          if (ourbigbookEditorElem.current &amp;&amp; ourbigbookEditorElem.current.ourbigbookEditor) {
                            ourbigbookEditorElem.current.ourbigbookEditor.editor.focus()
                          }
                        } else {
                          if (parentInputElem.current) {
                            parentInputElem.current.focus()
                          }
                        }
                      }
                    }}
                    placeholder={`${capitalize(itemType)} Title`}
                    ref={titleInputElem}
                    value={file.titleSource}
                    type="text"
                  /&gt;
                &lt;/Label&gt;
                &lt;ErrorList
                  errors={titleErrors.concat(convertTitleErrors)}
                  //oks={hasError ? undefined : ['Title looks good.']}
                /&gt;
                &lt;div className="tab-list"&gt;
                  {(!isIssue) &amp;&amp; &lt;&gt;
                    &lt;Link
                      className={`tab-item${tab === 'editor' ? ' active' : ''}`}
                      href={'#' /* TODO don't know how to make this empty. Like this it makes the URL be '#' which is ugly, but it works. */}
                      onClick={(ev) =&gt; {
                        ev.preventDefault()
                        window.location.hash = '' }}
                    &gt;
                      &lt;EditArticleIcon /&gt; Editor
                    &lt;/Link&gt;
                    &lt;Link
                      className={`tab-item${tab === 'metadata' ? ' active' : ''}`}
                      href={`#${metadataTabId}`}
                      onClick={(ev) =&gt; {
                        ev.preventDefault()
                        window.location.hash = `#${metadataTabId}`
                      }}
                    &gt;
                      &lt;MoreIcon /&gt; Metadata
                    &lt;/Link&gt;
                  &lt;/&gt;}
                  {' '}
                  &lt;button
                    className="btn"
                    type="button"
                    disabled={isLoading}
                    onClick={handleSubmit}
                    ref={saveButtonElem}
                    tabIndex={-1}
                  &gt;
                    &lt;OkIcon title={null} /&gt;&amp;nbsp;{isNew ? `Publish ${capitalize(itemType)}` : 'Save Changes'}
                  &lt;/button&gt;
                  {' '}
                  &lt;button
                    className="btn"
                    type="button"
                    onClick={handleCancel}
                    tabIndex={-1}
                  &gt;
                    &lt;CancelIcon title={null}/&gt;&amp;nbsp;Cancel
                  &lt;/button&gt;
                &lt;/div&gt;
              &lt;/div&gt;
              &lt;div className="tabs"&gt;
                &lt;div className={`editor-tab${tab === 'editor' ? '' : ' hide'}`}&gt;
                  &lt;div className="help"&gt;
                    &lt;CustomLink
                      href={`${docsUrl}#ourbigbook-markup-quick-start`}
                      newTab={true}
                    &gt;
                      &lt;HelpIcon /&gt; Learn how to write with our OurBigBook Markup format here!
                    &lt;/CustomLink&gt;
                  &lt;/div&gt;
                  &lt;div
                    className="ourbigbook-editor"
                    ref={ourbigbookEditorElem}
                  &gt;
                  &lt;/div&gt;
                &lt;/div&gt;
                &lt;div className={`metadata-tab${tab === 'metadata' ? '' : ' hide'}`}&gt;
                  {!isIssue &amp;&amp;
                    &lt;div ref={ourbigbookParentIdContainerElem}&gt;
                      {!isIndex &amp;&amp; &lt;&gt;
                        &lt;Label label="ID" &gt;
                          &lt;input
                            type="text"
                            className="title"
                            value={topicId}
                            disabled={true}
                          /&gt;
                        &lt;/Label&gt;
                        &lt;Label label="Parent" &gt;
                          &lt;input
                            type="text"
                            className="title"
                            placeholder={parentTitleDisplay}
                            value={parentTitle}
                            onChange={handleParentTitle}
                            ref={parentInputElem} /&gt;
                        &lt;/Label&gt;
                        &lt;Label label={previousSiblingTitleDisplay} &gt;
                          &lt;input
                            type="text"
                            className="title"
                            placeholder={`Article with same parent that comes before this one. Empty means first child.`}
                            value={previousSiblingTitle}
                            onChange={handlePreviousSiblingTitle}
                          /&gt;
                        &lt;/Label&gt;
                        &lt;ErrorList errors={parentErrors}/&gt;
                      &lt;/&gt;}
                      &lt;Label label="Unlisted" inline={true}&gt;
                        &lt;input
                          type="checkbox"
                          defaultChecked={!list}
                          onChange={(e) =&gt; { setList(!e.target.checked) }}
                        /&gt;
                      &lt;/Label&gt;
                    &lt;/div&gt;
                  }
                &lt;/div&gt;
              &lt;/div&gt;
            &lt;/&gt;
        }
      &lt;/div&gt;
    &lt;/&gt;
  }
  editor.isEditor = true
  return editor
}
</code></pre></div></div></main>
<footer>
<div>License: <a href="https://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a> unless noted</div>
<div><a href="../../../_dir">Website source code</a></div>
</footer>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-2XSEK2ND00"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-2XSEK2ND00');
</script>
<script src="https://giscus.app/client.js"
        data-repo="ourbigbook/ourbigbook"
        data-repo-id="MDEwOlJlcG9zaXRvcnkyMTEyOTA2NzA="
        data-category="giscus"
        data-category-id="DIC_kwDODJgKLs4CZ61S"
        data-mapping="pathname"
        data-strict="0"
        data-reactions-enabled="1"
        data-emit-metadata="0"
        data-input-position="bottom"
        data-theme="dark_high_contrast"
        data-lang="en"
        crossorigin="anonymous"
        async>
</script>
<script>
window.ourbigbook_split_headers = false;
window.ourbigbook_html_x_extension = false;
window.ourbigbook_redirect_prefix = "";
</script>
<script src="../../../_obb/dist/ourbigbook_runtime.js"></script><script>ourbigbook_runtime.ourbigbook_runtime()</script></body>
</html>
